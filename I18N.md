# Internationalization (i18n) Guide

This document describes the internationalization architecture and guidelines for the Swarmrise codebase.

## Overview

Swarmrise uses [react-i18next](https://react.i18next.com/) for internationalization, built on top of the [i18next](https://www.i18next.com/) framework. The system provides:

- Automatic language detection (localStorage, browser, HTML tag)
- Type-safe translation keys via TypeScript
- Namespace-based organization for maintainability
- Fallback to English when translations are missing

## Directory Structure

```
src/i18n/
├── index.ts              # i18n configuration and initialization
├── types.ts              # TypeScript type declarations for type safety
└── locales/
    ├── en/               # English (default/fallback language)
    │   ├── common.json
    │   ├── orgs.json
    │   ├── members.json
    │   ├── invitations.json
    │   ├── auth.json
    │   ├── teams.json
    │   └── governance.json
    ├── fr/               # French
    │   └── ... (same structure)
    ├── es/               # Spanish
    │   └── ...
    ├── it/               # Italian
    │   └── ...
    ├── uk/               # Ukrainian
    │   └── ...
    └── zh-TW/            # Traditional Chinese (Taiwan)
        └── ...
```

## Supported Languages

| Code    | Language             | Native Name  |
|---------|----------------------|--------------|
| `en`    | English              | English      |
| `fr`    | French               | Francais     |
| `es`    | Spanish              | Espanol      |
| `it`    | Italian              | Italiano     |
| `uk`    | Ukrainian            | Ukrainska    |
| `zh-TW` | Traditional Chinese  | Traditional Chinese |

English (`en`) is the fallback language. If a translation key is missing in any language, the English value will be displayed.

## Namespaces

Translations are organized into domain-specific namespaces:

| Namespace     | Purpose                                           |
|---------------|---------------------------------------------------|
| `common`      | Shared UI elements: buttons, labels, loading states, settings |
| `orgs`        | Organization management: creation, switching, leaving |
| `members`     | Member management: inviting, removing members     |
| `invitations` | Invitation flow: pending, accept, decline         |
| `auth`        | Authentication: login, logout, email verification |
| `teams`       | Teams and roles: team, role, duty, mission        |
| `governance`  | Governance features: decisions, policies, topics  |

The default namespace is `common`, so keys from `common.json` can be accessed without specifying a namespace.

## Usage in Components

### Basic Usage with useTranslation Hook

```tsx
import { useTranslation } from 'react-i18next';

function MyComponent() {
  // Uses default namespace (common)
  const { t } = useTranslation();

  return <button>{t('submit')}</button>;
}
```

### Using a Specific Namespace

```tsx
import { useTranslation } from 'react-i18next';

function OrganizationCard() {
  // Specify a namespace
  const { t } = useTranslation('orgs');

  return <h1>{t('createOrganization')}</h1>;
}
```

### Using Multiple Namespaces

```tsx
import { useTranslation } from 'react-i18next';

function InvitationPage() {
  const { t: tOrgs } = useTranslation('orgs');
  const { t: tCommon } = useTranslation('common');
  const { t: tInvitations } = useTranslation('invitations');

  return (
    <div>
      <h1>{tOrgs('organization')}</h1>
      <p>{tInvitations('pendingInvitations')}</p>
      <button>{tCommon('cancel')}</button>
    </div>
  );
}
```

### Interpolation (Dynamic Values)

Use double curly braces `{{variable}}` for dynamic content:

```json
// invitations.json
{
  "invitedBy": "Invited by {{name}}"
}
```

```tsx
function InvitationItem({ inviterName }) {
  const { t } = useTranslation('invitations');

  return <p>{t('invitedBy', { name: inviterName })}</p>;
}
```

### Nested Keys

Use dot notation for nested translation objects:

```json
// orgs.json
{
  "metrics": {
    "members": "Members",
    "teams": "Teams",
    "memberCount": "{{count}} members"
  }
}
```

```tsx
function OrgMetrics({ memberCount }) {
  const { t } = useTranslation('orgs');

  return (
    <div>
      <span>{t('metrics.members')}</span>
      <span>{t('metrics.memberCount', { count: memberCount })}</span>
    </div>
  );
}
```

## TypeScript Type Safety

The `src/i18n/types.ts` file provides type safety for translation keys. It uses module augmentation to extend i18next's types:

```typescript
import 'i18next'
import type enCommon from './locales/en/common.json'
import type enOrgs from './locales/en/orgs.json'
// ... other imports

declare module 'i18next' {
  interface CustomTypeOptions {
    defaultNS: 'common'
    resources: {
      common: typeof enCommon
      orgs: typeof enOrgs
      members: typeof enMembers
      invitations: typeof enInvitations
      auth: typeof enAuth
      teams: typeof enTeams
      governance: typeof enGovernance
    }
  }
}
```

This enables:
- Autocomplete for translation keys in your IDE
- Compile-time errors for invalid keys
- Type checking for interpolation variables

## Adding New Translations

### Adding a New Key to an Existing Namespace

1. Add the key to the English file first (source of truth):
   ```json
   // src/i18n/locales/en/common.json
   {
     "existingKey": "existing value",
     "newKey": "New translation"
   }
   ```

2. Add the same key to ALL other language files:
   ```json
   // src/i18n/locales/fr/common.json
   {
     "existingKey": "valeur existante",
     "newKey": "Nouvelle traduction"
   }
   ```

3. TypeScript types will automatically update (types are inferred from the English JSON files).

### Adding a New Namespace

1. Create JSON files in each language directory:
   ```
   src/i18n/locales/en/newNamespace.json
   src/i18n/locales/fr/newNamespace.json
   src/i18n/locales/es/newNamespace.json
   src/i18n/locales/it/newNamespace.json
   src/i18n/locales/uk/newNamespace.json
   src/i18n/locales/zh-TW/newNamespace.json
   ```

2. Update `src/i18n/index.ts`:
   ```typescript
   // Add imports for each language
   import enNewNamespace from './locales/en/newNamespace.json'
   import frNewNamespace from './locales/fr/newNamespace.json'
   // ... other languages

   // Add to resources object for each language
   const resources = {
     en: {
       // ... existing namespaces
       newNamespace: enNewNamespace
     },
     fr: {
       // ... existing namespaces
       newNamespace: frNewNamespace
     },
     // ... other languages
   }

   // Add to ns array in init config
   void i18n
     .use(LanguageDetector)
     .use(initReactI18next)
     .init({
       // ...
       ns: ['common', 'orgs', 'members', 'invitations', 'auth', 'teams', 'governance', 'newNamespace'],
       // ...
     })
   ```

3. Update `src/i18n/types.ts`:
   ```typescript
   import type enNewNamespace from './locales/en/newNamespace.json'

   declare module 'i18next' {
     interface CustomTypeOptions {
       resources: {
         // ... existing namespaces
         newNamespace: typeof enNewNamespace
       }
     }
   }
   ```

## Adding a New Language

1. Create a new directory under `src/i18n/locales/` with the language code (e.g., `de` for German).

2. Copy all JSON files from `en/` to the new directory and translate all values.

3. Update `src/i18n/index.ts`:
   ```typescript
   // Add imports
   import deCommon from './locales/de/common.json'
   import deOrgs from './locales/de/orgs.json'
   // ... all namespaces

   // Add to supportedLanguages
   export const supportedLanguages = ['en', 'fr', 'es', 'it', 'uk', 'zh-TW', 'de'] as const

   // Add to languageNames
   export const languageNames: Record<SupportedLanguage, string> = {
     // ... existing languages
     de: 'Deutsch'
   }

   // Add to resources
   const resources = {
     // ... existing languages
     de: {
       common: deCommon,
       orgs: deOrgs,
       members: deMembers,
       invitations: deInvitations,
       auth: deAuth,
       teams: deTeams,
       governance: deGovernance
     }
   }
   ```

## Best Practices

### Do

- **Use namespaces appropriately**: Place translations in the namespace that matches the feature domain
- **Keep keys descriptive**: Use clear, descriptive key names (e.g., `confirmRemoveMember` not `msg1`)
- **Use nested keys for related items**: Group related translations using nested objects
- **Add all languages simultaneously**: When adding a new key, add translations for all supported languages
- **Use interpolation for dynamic content**: Never concatenate translated strings with variables
- **Provide context for translators**: Use meaningful key names that indicate where/how the text is used

### Do Not

- **Never hardcode user-facing strings**: All visible text must go through the i18n system
- **Never use string concatenation**: Use interpolation instead of `t('hello') + name`
- **Never leave TODO translations**: Ensure all translations are complete before merging
- **Never duplicate keys**: If a translation exists in `common`, use it rather than duplicating
- **Never use translation keys as values**: Keys should be semantic, not the actual text

### Key Naming Conventions

| Pattern | Example | Use Case |
|---------|---------|----------|
| `noun` | `member`, `team` | Singular labels |
| `nounPlural` | `members`, `teams` | Plural labels |
| `verbNoun` | `createOrganization`, `removeMember` | Action buttons |
| `confirmVerb` | `confirmLogout`, `confirmRemove` | Confirmation dialogs |
| `nounDescription` | `enterEmailToInvite` | Descriptive text/instructions |
| `parent.child` | `metrics.memberCount` | Nested/grouped translations |

### Interpolation Patterns

```json
{
  "simpleCount": "{{count}} items",
  "namedValue": "Welcome, {{name}}!",
  "multipleValues": "{{name}} invited you to {{orgName}}"
}
```

## Language Detection

The system detects the user's language in the following order:

1. **localStorage**: Checks for a previously saved preference
2. **navigator**: Uses the browser's language setting
3. **htmlTag**: Falls back to the `lang` attribute on the HTML element

Users can change their language preference, which is persisted to localStorage for future visits.

## Testing i18n Changes

1. **Visual inspection**: Switch between languages in the app to verify translations appear correctly
2. **Missing key detection**: Check browser console for i18next warnings about missing keys
3. **Interpolation testing**: Verify dynamic values render correctly in all languages
4. **Layout testing**: Ensure translations fit in the UI (some languages are more verbose)

## Troubleshooting

### Translation not appearing

1. Verify the key exists in all language files
2. Check you are using the correct namespace in `useTranslation()`
3. Look for typos in the translation key
4. Check browser console for i18next errors

### TypeScript errors on translation keys

1. Ensure the key exists in the English JSON file (types are derived from English)
2. Restart your TypeScript server (VS Code: Cmd/Ctrl + Shift + P > "TypeScript: Restart TS Server")
3. Verify the types.ts file imports the correct namespace

### Interpolation not working

1. Verify the variable name matches between JSON and code: `{{name}}` requires `{ name: value }`
2. Check for typos in variable names
3. Ensure the variable is passed as an object, not a string
